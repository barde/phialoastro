---
// Lightweight Web Vitals monitoring
---

<script type="module">
  // Dynamic import from CDN to avoid bundling issues
  // Using attribution build for detailed debugging info
  const { onCLS, onINP, onLCP, onFCP, onTTFB } = await import('https://unpkg.com/web-vitals@5/dist/web-vitals.attribution.js');

  // Configuration for sending metrics
  const METRICS_ENDPOINT = '/api/vitals';
  const BATCH_SIZE = 5;
  const BATCH_TIMEOUT = 5000; // 5 seconds
  
  // Batch metrics to reduce network requests
  let metricsQueue = [];
  let batchTimer = null;

  /**
   * Get page context for better analysis
   */
  function getPageContext() {
    const path = window.location.pathname;
    const lang = path.startsWith('/en/') ? 'en' : 'de';
    const pageType = detectPageType(path);
    
    return {
      path,
      lang,
      pageType,
      viewport: {
        width: window.innerWidth,
        height: window.innerHeight
      },
      connection: navigator.connection ? {
        effectiveType: navigator.connection.effectiveType,
        downlink: navigator.connection.downlink,
        rtt: navigator.connection.rtt,
        saveData: navigator.connection.saveData
      } : null,
      deviceMemory: navigator.deviceMemory || null,
      hardwareConcurrency: navigator.hardwareConcurrency || null,
      timestamp: new Date().toISOString(),
      sessionId: getSessionId(),
      referrer: document.referrer || null
    };
  }

  /**
   * Detect page type from URL path
   */
  function detectPageType(path) {
    const cleanPath = path.replace(/^\/en/, '').replace(/\/$/, '');
    
    if (cleanPath === '' || cleanPath === '/') return 'home';
    if (cleanPath.includes('/portfolio')) return 'portfolio';
    if (cleanPath.includes('/services')) return 'services';
    if (cleanPath.includes('/tutorials')) return 'tutorials';
    if (cleanPath.includes('/about')) return 'about';
    if (cleanPath.includes('/contact')) return 'contact';
    if (cleanPath.includes('/legal')) return 'legal';
    
    return 'other';
  }

  /**
   * Get or create a session ID for correlating metrics
   */
  function getSessionId() {
    let sessionId = sessionStorage.getItem('vitals-session-id');
    if (!sessionId) {
      sessionId = `${Date.now()}-${Math.random().toString(36).substring(2, 11)}`;
      sessionStorage.setItem('vitals-session-id', sessionId);
    }
    return sessionId;
  }

  /**
   * Send metrics batch to endpoint
   */
  function sendMetricsBatch() {
    if (metricsQueue.length === 0) return;
    
    const batch = [...metricsQueue];
    metricsQueue = [];
    
    const payload = JSON.stringify({
      metrics: batch,
      context: getPageContext()
    });
    
    // Use sendBeacon for reliability, especially during page unload
    if (navigator.sendBeacon) {
      navigator.sendBeacon(METRICS_ENDPOINT, payload);
    } else {
      // Fallback for older browsers
      fetch(METRICS_ENDPOINT, {
        method: 'POST',
        body: payload,
        keepalive: true,
        headers: {
          'Content-Type': 'application/json'
        }
      }).catch(err => {
        console.debug('Failed to send metrics:', err);
      });
    }
  }

  /**
   * Queue metric for batching
   */
  function queueMetric(metric) {
    // Add enhanced metric data
    const enhancedMetric = {
      name: metric.name,
      value: metric.value,
      rating: metric.rating,
      delta: metric.delta,
      id: metric.id,
      navigationType: metric.navigationType,
      attribution: {}
    };
    
    // Add attribution data based on metric type
    if (metric.attribution) {
      switch (metric.name) {
        case 'LCP':
          enhancedMetric.attribution = {
            element: metric.attribution.element,
            url: metric.attribution.url,
            timeToFirstByte: metric.attribution.timeToFirstByte,
            resourceLoadDelay: metric.attribution.resourceLoadDelay,
            resourceLoadDuration: metric.attribution.resourceLoadDuration,
            elementRenderDelay: metric.attribution.elementRenderDelay,
            navigationEntry: metric.attribution.navigationEntry,
            lcpEntry: metric.attribution.lcpEntry
          };
          break;
          
        case 'CLS':
          enhancedMetric.attribution = {
            largestShiftTarget: metric.attribution.largestShiftTarget,
            largestShiftValue: metric.attribution.largestShiftValue,
            largestShiftTime: metric.attribution.largestShiftTime,
            largestShiftEntry: metric.attribution.largestShiftEntry,
            sources: metric.attribution.sources
          };
          break;
          
        case 'INP':
          enhancedMetric.attribution = {
            eventTarget: metric.attribution.eventTarget,
            eventType: metric.attribution.eventType,
            eventTime: metric.attribution.eventTime,
            eventEntry: metric.attribution.eventEntry,
            loadState: metric.attribution.loadState,
            inputDelay: metric.attribution.inputDelay,
            processingDuration: metric.attribution.processingDuration,
            presentationDelay: metric.attribution.presentationDelay
          };
          break;
          
        case 'FCP':
          enhancedMetric.attribution = {
            timeToFirstByte: metric.attribution.timeToFirstByte,
            firstByteToFCP: metric.attribution.firstByteToFCP,
            loadState: metric.attribution.loadState,
            navigationEntry: metric.attribution.navigationEntry,
            fcpEntry: metric.attribution.fcpEntry
          };
          break;
          
        case 'TTFB':
          enhancedMetric.attribution = {
            waitingDuration: metric.attribution.waitingDuration,
            dnsDuration: metric.attribution.dnsDuration,
            connectionDuration: metric.attribution.connectionDuration,
            requestDuration: metric.attribution.requestDuration,
            navigationEntry: metric.attribution.navigationEntry
          };
          break;
      }
    }
    
    metricsQueue.push(enhancedMetric);
    
    // Clear existing timer
    if (batchTimer) {
      clearTimeout(batchTimer);
    }
    
    // Send batch if size reached or set timer
    if (metricsQueue.length >= BATCH_SIZE) {
      sendMetricsBatch();
    } else {
      batchTimer = setTimeout(sendMetricsBatch, BATCH_TIMEOUT);
    }
  }

  function logMetric(metric) {
    // Only log in development mode to reduce console noise
    // Check if we're in development by looking at the hostname
    const isDev = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
    if (isDev) {
      console.log(`[WV] ${metric.name}: ${metric.value.toFixed(2)} (${metric.rating})`);
    }
  }

  /**
   * Handle each metric
   */
  function handleMetric(metric) {
    logMetric(metric);
    queueMetric(metric);
  }

  // Register all Web Vitals observers
  onCLS(handleMetric);
  onINP(handleMetric);
  onLCP(handleMetric);
  onFCP(handleMetric);
  onTTFB(handleMetric);

  // Send any remaining metrics when page unloads
  window.addEventListener('visibilitychange', () => {
    if (document.visibilityState === 'hidden') {
      sendMetricsBatch();
    }
  });

  // Also handle beforeunload for older browsers
  window.addEventListener('beforeunload', sendMetricsBatch);

  // Performance marks for custom metrics
  if (window.performance && window.performance.mark) {
    // Mark when vitals monitoring initialized
    window.performance.mark('vitals-monitor-init');
    
    // Observe for Astro-specific metrics
    if (window.performance.getEntriesByType) {
      // Check for hydration timing
      const observer = new PerformanceObserver((list) => {
        for (const entry of list.getEntries()) {
          if (entry.name.includes('astro-island')) {
            queueMetric({
              name: 'astro-hydration',
              value: entry.duration,
              rating: entry.duration < 50 ? 'good' : 
                     entry.duration < 100 ? 'needs-improvement' : 'poor',
              id: entry.name,
              navigationType: 'navigate'
            });
          }
        }
      });
      
      observer.observe({ entryTypes: ['measure'] });
    }
  }
</script>